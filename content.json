[{"title":"js常见用法","date":"2017-03-09T10:38:54.000Z","path":"2017/03/09/js-common-method/","text":"冒泡排序 123456789101112var arr = [3,2,1,9,7];for(var i = 0; i &lt; arr.length; i++)&#123; for(var j = 0; j &lt;= arr.length-i; j++)&#123; var temp; if(arr[j] &gt; arr[j+1])&#123; temp = arr[j] arr[j] = arr[j+1] arr[j+1] = temp &#125; &#125;&#125;console.log(arr) 翻转字符串 方法一 123456var str = &apos;翻转字符串一&apos;var tem = &apos;&apos;;for(var i = str.length-1; i &gt;= 0; i--)&#123; tem += str[i];&#125;console.log(tem); 方法二 123var str = &apos;翻转字符串二&apos;;var arrStr = str.split(&apos;&apos;).reverse().join().replace(/,/g, &quot;&quot;);console.log(arrStr) 方法三 123456789101112var str = &apos;翻转字符串三&apos;;var arr = str.split(&apos;&apos;);var i = 0, j = arr.length-1, tem;while(i &lt; j)&#123; tem = arr[i]; arr[i] = arr[j]; arr[j] = tem; i++; j--&#125;arr = arr.join(&apos;&apos;);console.log(arr) 数组去重 方法一 123456789var arr = [3,3,4,9,3,4,5];var newArr = [];for(var i in arr)&#123; console.log(arr[i]) if(newArr.indexOf(arr[i]) == -1)&#123; newArr.push(arr[i]); &#125;&#125;console.log(newArr) 方法二 1234567891011var arr = [3,4,9,3,4,5];var newArr = [];for(var i = 0, l = arr.length; i&lt;l; i++)&#123; for(var j = i+1; j &lt; l; j++)&#123; if(arr[i] == arr[j])&#123; j = ++i; &#125; &#125; newArr.push(arr[i]);&#125;console.log(newArr)","tags":[]},{"title":"诗集","date":"2015-11-23T10:32:42.000Z","path":"2015/11/23/诗/","text":"《偶然》 — 徐志摩 我是天空里的一片云偶尔投影在你的波心你无需讶异更无需欢喜在转瞬间消失了踪影你我相逢在黑夜的海上你有你的我有我的方向你记得也好，最好你忘掉在这交会时互放的光亮 《我喜欢出发》 — 汪国真 我喜欢出发。 凡是到达了的地方，都属于昨天。哪怕那山再青，那水再秀，那风再温柔。太深的流连便成了一种羁绊，绊住的不仅有双脚，还有未来。 怎么能不喜欢出发呢?没见过大山的巍峨，真是遗憾；见了大山的巍峨没见过大海的浩瀚仍然遗憾；见了大海的浩瀚没见过大漠的广袤，依旧遗憾；见了大漠的广袤没见过森林的神秘，还是遗憾。世界上有不绝的风景，我有不老的心情。 我自然知道，大山有坎坷，大海有浪涛，大漠有风沙，森林有猛兽。即便这样，我依然喜欢。 打破生活的平静便是另一番景致，一种属于年轻的景致。真庆幸，我还没有老。即便真老了又怎么样，不是有句话叫老当益壮吗? 于是，我还想从大山那里学习深刻，我还想从大海那里学习勇敢，我还想从大漠那里学习沉着，我还想从森林那里学习机敏。我想学着品味一种缤纷的人生。 人能走多远?这话不是要问两脚而是要问志向；人能攀多高?这事不是要问双手而是要问意志。于是，我想用青春的热血给自己树起一个高远的目标。不仅是为了争取一种光荣，更是为了追求一种境界。目标实现了，便是光荣；目标实现不了，人生也会因这一路风雨跋涉变得丰富而充实；在我看来，这就是不虚此生。 是的，我喜欢出发，愿你也喜欢。","tags":[]},{"title":"nodejs-mongoose","date":"2015-05-28T12:19:09.000Z","path":"2015/05/28/node-mongoose/","text":"了解db相关操作，先以mongoose为主 首先我们应已成功安装 MongoDB 和 Node.js并已安装express，然后使用express快速创建一个应用程序： express node-mongoose 切换到目录并安装依赖： cd node-mongoose &amp;&amp; npm install 然后让我们运行它: npm start 可以看到一个简单的应用就生成了, 接下来我们给这个应用添加数据库，这里我们使用mongoose操作mongodb, 1.首先安装mongoose npm install mongoose 2.配置mongoose 增加db.js文件，添加以下内容，指定数据库名为nodedb var mongoose = require('mongoose'); mongoose.connect('mongodb://127.0.0.1/nodedb'); exports.mongoose = mongoose; 3.创建数据模型文件 user.js var mongodb = require('./mongodb'); var Schema = mongodb.mongoose.Schema; var UserSchema = new Schema({ username:\"String\", password:\"String\", created_at: { type: Date, default: Date.now() } }) var UserModel = mongoose.model('UserModel', UserSchema); module.exports = UserModel;","tags":[]},{"title":"Gulp + Gulp-connect + watch + livereload","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/gulp-livereload/","text":"Gulp + Gulp-connect + watch + livereload：使用gulp插件gulp-connect在本地启动一个Web Server，然后通过watch任务和livereload监视文件的改变，触发浏览器页面自动刷新 用法 安装 gulp npm install gulp -g 安装 gulp-connect: npm install gulp-connect -g gulpfile.js文件脚本 //引入插件 var gulp = require('gulp'); var connect = require('gulp-connect'); //创建watch任务去检测文件的改动 gulp.task('watch', function () { gulp.watch(['../../../src/*.html'], ['html']); }); //使用connect启动一个Web服务器 gulp.task('connect', function () { connect.server({ root: '../../../src', livereload: true }); }); //调用要执行的任务 gulp.task('html', function () { gulp.src('../../../src/*.html').pipe(connect.reload()); }); //运行任务 gulp.task('default', ['connect', 'watch']); 在项目目录下运行命令gulp","tags":[]},{"title":"Express 文件上传 - Multer","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/express-multer/","text":"安装所需模块 npm install --save multer 用法，在app.js添加以下代码： var express = require('express') var multer = require('multer') var app = express() app.use(multer({ dest: './uploads/', rename: function (fieldname, filename) { return filename.replace(/\\W+/g, '-').toLowerCase() + Date.now() } })) 路由模块 router.post('/uploadimage',function(req,res){ res.status(200).json({ file:req.files }); }); 上传部分的html代码 &lt;form id='editfile' method='post' action='/uploadimage' enctype='multipart/form-data'&gt; &lt;input type=\"text\"/&gt; 选择图片：&lt;input id='upfile' type='file'/&gt; &lt;input type='submit' value='提交'/&gt; &lt;/form&gt; enctype=”multipart/form-data”的作用是设置表单上传文件的正确编码，浏览器用表单提交数据的格式 使用ajax上传： $('#editfile').submit(function (e) { var data = new FormData(); data.append('file', $('#upfile')[0].files[0]); $.ajax({ url: '/uploadimage', data: data, processData: false, contentType: false, type: 'POST', success: function(data){ console.log(data); //返回上传后所在的路径 } }); e.preventDefault(); }); 使用angularjs $http上传： $http({ url:'/uploadimage', method: 'POST', headers: { 'Content-Type': undefined }, transformRequest: function() { var formData = new FormData(); formData.append('file', $('#upfile')[0].files[0]); return formData; } }).success(function (data) { console.log(data); //返回上传后所在的路径 });","tags":[]},{"title":"","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/comand/","text":"launchctl load ~/Library/LaunchAgents/homebrew.mxcl.php55.plist launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.php55.plist launchctl load ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist sudo nginxsudo nginx -s stopsudo nginx -s restartsudo nginx -s reload","tags":[]},{"title":"gulp-coffee-demo","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/gulp-coffee-demo/","text":"Step npm init 创建package.json文件 安装所需模块 npm install --save gulp npm install --save gulp-coffee npm install --save gulp-coffeelint 创建 src build 文件夹，并在src里创建一个.coffee文件 创建 Gulpfile.js var gulp = require('gulp'); var coffee = require('gulp-coffee'); var coffeelint = require('gulp-coffeelint'); var coffeescript_files = ['./src/**/*.coffee']; var build_dir = './build/'; //校验coffee语法的任务 gulp.task('validate_coffee', function () { gulp.src(coffeescript_files) .pipe(coffeelint()) .pipe(coffeelint.reporter()); }); //把coffee脚本编译为js的任务 gulp.task('compile_coffee', ['validate_coffee'], function() { gulp.src(coffeescript_files) .pipe(gulp.dest(build_dir)); }); gulp.task('default', ['compile_coffee']); 在命令行执行 gulp","tags":[]},{"title":"nginx 安装","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/deploy-server/","text":"➜ ~ ssh root@123.50.222.30 The authenticity of host ‘123.50.222.30 (123.50.222.30)’ can’t be established.RSA key fingerprint is 16:d5:f2:e6:9b:c8:c2:32:ca:22:35:f8:f3:64:a7:e1.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘123.57.222.30’ (RSA) to the list of known hosts.root@123.50.222.30’s password: 111111 Last login: Wed Jun 10 17:33:35 2015 from 117.10.146.80 Welcome to aliyun Elastic Compute Service! [root@iZ25xk7uei1Z ~]# useradd deploy //添加用户[root@iZ25xk7uei1Z ~]# ls /home //查看用户deploy[root@iZ25xk7uei1Z ~]# passwd deploy //添加密码 更改用户 deploy 的密码 。 新的 密码：111111 重新输入新的 密码：111111 passwd：所有的身份验证令牌已经成功更新。 [root@iZ25xk7uei1Z ~]# su - deploy //从root用户切换到普通用户，切换至root用户: su $ yum info nginx //查看nginx信息$ sudo yum install nginx //安装nginx$ sudo service nginx start //启动服务$ sudo service nginx status //查看启动状态vi /etc/nginx/nginx.conf //查看配置文件 新建目录并进入 mkdir downloads &amp;&amp; cd downloads 下载mongodb wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.3.tgz 解压： tar -xzf mongodb-linux-x86_64-3.0.3.tgz 重命名 mv mongodb-linux-x86_64-3.0.3 mongodb 进入bin目录，查看文件 cd bin/ $ ls bsondump mongo mongod mongodump mongoexport mongofiles mongoimport mongooplog mongoperf mongorestore mongos mongostat mongotop 新建一个配置文件并写入配置信息 vi mongodb.conf 配置信息如下： dbpath = /home/deploy/downloads/mongodb/data/test/db #数据文件存放目录logpath = /home/deploy/downloads/mongodb/data/test/logs/mongodb.log #日志文件存放目录port = 27017 #端口fork = true #以守护程序的方式启用，即在后台运行nohttpinterface = true 在mongodb目录下创建目录 /home/deploy/downloads/mongodb/data/test/db 创建日志文件目录 /home/deploy/downloads/mongodb/data/test/logs/ 在bin目录下启动./mongod —config mongodb.conf 注意事项bin/mongodb.conf中的路径一定要和实际的路径对应配置文件中，dbpath是一个目录路径，logpath是一个路径及日志文件 安装nvm ： $ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.25.4/install.sh | bash 使命令生效： source ~/.nvm/nvm.sh 查看 node版本： nvm ls-remote 安装所需版本： nvm install v0.12.4 查看node版本： node -v v2.2.1 安装pm2: npm install -g pm2 运行pm2 pm2 start app.js 软链接： ln -s a b // a 就是源文件，b是链接文件名,其作用是当进入b目录，实际上是链接进入了a目录","tags":[]},{"title":"angularjs filter 过滤器","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/angularjs-filter/","text":"uppercase：字符串全部大写字符显示： \\{\\{ name | uppercase \\}\\} lowercase:字符串全部小写字符显示 \\{\\{ Name | lowercase \\}\\} number: 数字格式化 \\{\\{ 1234567890 | number \\}\\} 1,234,567,890 格式化数字到一位小数 \\{\\{ 1.234567 | number:1 \\}\\} 1.2 currency:把数字格式化成货币，默认美元符 \\{\\{ 123 | currency \\}\\} $123.00 格式化成人民币符 \\{\\{ 123 | currency:&#39;￥&#39;\\}\\} ￥123.00 limitTo: 根据传递的参数值来生成新的数组或字符串，参数值为整数，从开头截取，参数为负值，从最后开始截取 \\{\\{ &quot;hello world&quot; | limitTo:5 \\}\\} hello","tags":[]},{"title":"Hello World","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in trobuleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Mac OS X 系统开发设置","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/mac-dev-setup/","text":"本文讲述我是如何在一台新的MacBook或iMac上设置我的开发环境的,我们将设置Node (JavaScript), Python, 和 Ruby环境，主要用于JavaScript和Python开发，即使你不用这三个中的任何一个来开发，把其中的任何一个当成命令行工具来使用也是不错的，如果你阅读并按照这些步骤来做了,随时给我发送任何反馈或评论。 此文档假设你刚开始使用Mac。下面的步骤在OS X Mountain Lion上进行了测试。如果你有任何意见或建议,请在Twitter上给我留言! 系统更新你需要做的第一件事,实际上在任何操作系统首先要做的都是,更新系统 :屏幕左上角苹果图标 &gt; 软件更新 系统设置如果这是一台新电脑，我喜欢对系统首选项做一些调整。是否按照这些来做这取决于你的个人喜好。屏幕左上角苹果图标 &gt; 系统设置:·触控板&gt;点击·键盘&gt;键重复&gt;快(向右)·键盘&gt;延时直到重复&gt;短(向右)·Dock &gt;自动隐藏和显示Dock","tags":[]},{"title":"populate","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/populate/","text":"populate方法可以通过一个Schema使用ref引用另一个Schema建立起表和表之间的关联，并使用ID定义外键约束便于查询关联的表中相关内容。 var PostSchema = new Schema({ title: { type: String, required: true }, content: { type: String }, create_by:{ type: Schema.ObjectId, ref: 'MemberSchema' //关联MemberSchema表 }, create_at: { type: Date, default: Date.now } }); 保存外键ID用于建立关系： Post.create({ title:'1111111111', content:'ffdddsfdsfdsfsd', create_by:ObjectId },function(err,data){ if(err){ console.log(err) }else{ console.dir(data); process.exit(); } }) 使用populate方法查询： Post.find({\"_id\":mongoose.Types.ObjectId(\"55c2d27dcf2730a80ab7407f\")}).populate('create_by').exec(function(err,data){ if(err){ console.log(err) }else{ console.dir(data); process.exit(); } });","tags":[]},{"title":"node supervisor","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/supervisor/","text":"supervisorsupervisor 是node开发工具，node应用修改源码以后，需要重启node，使用supervisor后它会监视文件的改变，然后自动重新启动node supervisor用法 使用 npm 安装 supervisor npm install supervisor -g 如出现权限错误，使用 sudo npm install supervisor -g 使用 supervisor 命令启动 app.js: supervisor app.js","tags":[]},{"title":"Small js","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/smalljs/","text":"PagePage是一个轻量级的用来构建单页应用的客户端路由库，它有一个受Express的启发而来的简单的API，你可以用它构建平滑的用户界面,并且应用程序不同的页面都拥有可链接的url，因为它利用了HTML5 history API RoutingPage 提供了一些不同作用的一个page函数： var page = require('page'); 第一个作用是指定路由，如果你使用Ruby on Rails或Express或类似的框架,这应该看起来很熟悉: page('/', function(){ // Do something to set up the index page }); page('/about', function(){ // Set up the about page }); 你的路由可以包含参数,你可以通过上下文判定的参数来处理你的路由 page('/user/:id', function(context){ var userId = context.params.id; console.log('Loading details for user', userId); }); 你也可以使用通配符来作为参数,在这种情况下,你将需要使用数组索引访问参数: page('/files/*', function(context){ var filePath = context.params[0]; console.log('Loading file', filePath); }); 使用通配符和命名参数的一个关键区别是通配符可以匹配字符“/”,而命名的参数不能。在我们的文件路径示例中,使用通配符时文件路径可以包含任意嵌套的子目录。 使用通配符的另一个有用的方法是定义一个回退的路由: page('*', function(){ console.error('Page not found :('); }); Starting The Router一旦你定义了所有的路由,当其他页面访问完毕之后,你需要启动路由,但这一次没有参数: page(); 如果这样写你觉得很奇怪，想要更明确一点，也可以写成： page.start(); 这两个都有一个可选的参数对象,包含以下属性: click - 是否自动绑定到页面上的点击事件和拦截链接点击和阻止它们使用页面的链接路由的默认值为true. popstate - 是否绑定到和利用popstate event——默认值为true。 dispatch - 是否基于当前url执行初始路由dispatch,默认值为true。 Programmatic Navigation正如上面提到的,页面将默认自动拦截点击页面上的链接,并试图处理它使用你设置的路线。只有当它不能匹配定义的url与任何路由时将会默认返回浏览器的默认行为。可是有时,你可能想要改变基于其他事件的URL。也许碰巧点击了元素之外的其他链接。或者,如果您正在构建一个搜索页面,您可能希望允许用户分享他们的搜索结果的URL。你可以在你想浏览的页面中调用page的方法: $(form).on('submit', function(e){ e.preventDefault(); page('/search?' + form.serialize()); }); 如果你喜欢更明确一点,你可以使用 page.show(path)。 Route Handler Chainingpage 的一个很酷的功能是允许路由处理链接，这类似于express的中间件，一个路由定义可以处理多个程序 page('user/:id', loadUser, showUser); 在这里，当导航路径是user/:id时,page 将会调用loadUser函数，当用户加载完成时，它会调用showUser函数来展示它，那它是如何知道用户加载完成了呢,它提供了一个回调函数作为第二个参数—-这就是loadUser可能看起来像: function loadUser(ctx, next){ var id = ctx.params.id; $.getJSON('/user/' + id + '.json', function(user){ ctx.user = user; next(); }); } 然后，在showUser里你可以通过ctx.user得到user，现在你可以重用loadUser函数，例如，user/:id 编辑路由。 StatesHistory API 支持保存状态以及每个历史入口，它允许你缓存信息以及访问过的导航地址，这样当用户导航通过返回按钮返回时，无需重新载入信息，使用户体验更为顺畅，Page通过state属性的context对象暴露出来这些，使上述loadUser函数利用这个缓存，你可以这样写： function loadUser(ctx, next){ if (ctx.state.user){ next(); }else{ var id = ctx.params.id; $.getJSON('/user/' + id + '.json', function(user){ ctx.state.user = user; ctx.save(); // saves the state via history.replaceState() next(); }); } } Putting It All Together现在你已经知道关于Page你需要了解的了，我们来构建一个应用程序示例，这个app将会呈现一个最早的Github用户列表，你可以点击一个个人用户获取和他相关的更多详情，后退按钮应该使用缓存无缝的工作，这将使用到的模块有page,superagent,和mustache. var page = require('page'); var request = require('superagent'); var mustache = require('mustache'); 下面是定义的路由： page('/', loadUsers, showUsers); page('/user/:id', loadUser, showUser); loadUsers和loadUser的实现看起来就像这个样子，有点像以前的state-caching例子： function loadUsers(ctx, next){ if (ctx.state.users){ // cache hit! next(); }else{ // not cached by state, make the request request('https://api.github.com/users', function(reply){ var users = reply.body; ctx.state.users = users; ctx.save(); next(); }); } } function loadUser(ctx, next){ if (ctx.state.user){ next(); }else{ var id = ctx.params.id; request('https://api.github.com/user/' + id, function(reply){ var user = reply.body; ctx.state.user = user; ctx.save(); next(); }); } } 使用mustache来渲染页面，我做了如下模板： var listTemplate = '&lt;h1&gt;Early Github Users&lt;/h1&gt;\\ &lt;ul&gt;\\ {{a}}\\ &lt;li&gt;\\ &lt;a href=\"/user/{{id}}\"&gt;{{login}}&lt;/a&gt;\\ &lt;/li&gt;\\ {{a}}\\ &lt;/ul&gt;'; var showTemplate = '&lt;h1&gt;User {{login}}&lt;/h1&gt;\\ &lt;p&gt;{{name}} is user number {{id}}. \\ He has {{followers}} followers, \\ {{public_repos}} public repos and writes a blog at\\ &lt;a href=\"{{blog}}\"&gt;{{blog}}&lt;/a&gt;.\\ &lt;a href=\"/\"&gt;Back to list&lt;/a&gt;.&lt;/p&gt;\\ '; showUser和showUsers负责渲染这些模板： function showUsers(ctx){ var users = ctx.state.users; content.innerHTML = mustache.render(listTemplate, users); } function showUser(ctx){ var user = ctx.state.user; content.innerHTML = mustache.render(showTemplate, user); }; 最后，我们需要启动路由： page.start(); 现在，你已经拥有了一个多页的单页应用，如果你想获得这些代码，在github上查看已经模块化成小文件的 完整的源码，","tags":[]},{"title":"十分钟自动化构建","date":"2015-02-25T10:08:36.000Z","path":"2015/02/25/gulp自动化构建/","text":"—- by 野狗 你是否还在手动压缩图片、js、css？是否还在手动编译sass、less、coffee？是否还在手动合并精灵图？是否还在…… 简单点，干活的方式简单点。 在前端技术飞速发展的今天，如果你还在日复一日地重复着那无休止的体力劳动，那你要反思了，这年头不懂捣鼓个工作流出来都不好意思说自己学前端的。 毕竟javascript是最好的编程语言嘛。:) 玩笑开到这里，到底什么是工作流？ 工作流（Workflow），指“业务过程的部分或整体在计算机应用环境下的自动化”。 ——百度百科 如题，此次的分享主题”自动化构建”，目的便是介绍如何根据需要搭建一套工作流，由浅入深。 1.前提往下看之前，请自备以下知识： nodejs的一些基础用法，比如：node index.js； npm的基本用法init、(un)install、run等； 了解gulp、webpack（本章不会用到）的用途 以上知识点请务必掌握，不然没法接着往下讲，切勿好高骛远；如果你准备好了，那我们就开始了！ 我们先来设定一个简单的需求： 一个本地开发环境，具备监控文件变化并实时更新的功能； 修改代码，保存之后浏览器自动刷新 实时编译各种预编译格式文件 压缩合并静态资源，打包输出 部署上传 2.源码首先新建一个项目文件夹project，接着我们打开命令行工具，切换到这个目录下，开始初始化这个项目： cd project npm init 按照提示完成初始化，打开项目我们会得到一个package.json文件像这样： 123456789101112 // package.json&#123; &quot;name&quot;: &quot;project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a test project&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;node ./build/test.js&quot; &#125;, &quot;author&quot;: &quot;jack lo&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 紧接着我们先来创造一份源码，结构如下： 12345678910- project |- src // 源文件夹 | |- tpl | | `- index.html | |- css | | `- index.css | |- js | | `- index.js |- dist // 打包文件夹 `- package.json 3. 编译打包一切材料就绪，我们开始安装工具包，这一次我们主要使用gulp来构建，不需要用到webpack，同时，为了实现浏览器自动刷新的功能，我们还需要用到browser-sync。 npm install gulp browser-sync --save-dev 这需要花点时间。 ————— 虚度光阴中 ————- 事实上，这里有个小坑需要我们提前准备一下，因为我们接下来会用到gulp的cli，所以这里我们需要全局安装gulp，没错，我就是设套让你装两遍！ 这是个好习惯，请务必以后也坚持这么做。把开发时候用到的所有npm包都记录在package.json文件中，可以方便日后自己以及他人的使用。 npm install gulp -g mac用户可能还要sudo一下： sudo npm install gulp -g 回车后按提示输入密码，继续回车，就可以正常安装了。 ————— 再一次虚度光阴中 ————- ok，安装完后，我们可以开始做点有意义的事了。 gulp的用法其实相当简单，api也就那么几个。简单来说，就是写好一个配置文件gulpfile.js，然后在命令行里执行它。 首先在根目录下新建一个gulpfile.js，然后随便建一个叫做test的任务： 1234567// gulpfile.jsvar gulp = require(&apos;gulp&apos;)// 创建一个名为test的任务，任务内容只是简单地在控制台输出一段文本gulp.task(&apos;test&apos;, function () &#123; return console.log(&apos;this is a test&apos;)&#125;) ok，保存。然后我们回到命令行，输入以下命令然后回车 gulp test gulp后面跟的是你所要执行的任务名，于是我们得到了这样一个结果 1234[22:56:35] Using gulpfile ~/project/gulpfile.js[22:56:35] Starting &apos;test&apos;...this is a test[22:56:35] Finished &apos;test&apos; after 149 μs 成功输出文本！恭喜，你已经掌握了gulp一半以上的用法。 现在我们尝试着来操作文件，我们将src/html里面的html文件给拷贝到dist文件夹（如果不存在则新建）里面去，怎么做？// 创建一个copy的任务 1234gulp.task(&apos;copy&apos;, function () &#123; return gulp.src(&apos;src/tpl/*.html&apos;) .pipe(gulp.dest(&apos;dist&apos;))&#125;) 这里的pipe其实是一种管道，你可以一直pipe连着pipe下去，也就是这个工作流可以一直这样一层层执行下去，随便你定义多少个处理任务都行，这就是gulp的特点，简单明了的工作流程。很多人不明白gulp到底是做什么的，其实到这里，就可以有个大概的认识了： gulp是以定义并执行一个个任务的形式来工作的流程管理工具，它的作用在于提供一套简单易用的工作方式。 在gulp以前，处理一份sass文件，你可能需要先执行一次编译的任务，编译成css之后，再执行一遍压缩css的任务，压缩完之后，再手动拷贝到打包文件夹里。原本需要分三步来操作的一件事情，在gulp里面就是一个任务的sei而已： 1234567// 创建一个css的处理任务gulp.task(&apos;sass&apos;, function () &#123; return gulp.src(&apos;src/sass/*.scss&apos;) .pipe(sass()) .pipe(minifycss()) .pipe(gulp.dest(&apos;dist/static&apos;))&#125;) 甚至我们可以同时执行多个任务，我可以定义好coffee、sass、image、html的四个任务，再把他们合并到一个任务当中去，一次性执行完： 12// 创建一个build的处理任务gulp.task(&apos;build&apos;, [&apos;coffee&apos;, &apos;sass&apos;, &apos;image&apos;, &apos;html&apos;]) 我只需要： gulp build 回车，这酸爽。 好了，介绍了这么多内容，最后我们还是回到最开始那份需求的实现上来。 我们来建几个任务，分别处理js、css、html文件，把js和css文件放到dist/static目录下，把html文件放到dist下： 12345678910111213141516gulp.task(&apos;css&apos;, function () &#123; return gulp.src(&apos;src/css/*.css&apos;) .pipe(gulp.dest(&apos;dist/static&apos;))&#125;)gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(gulp.dest(&apos;dist/static&apos;))&#125;)gulp.task(&apos;html&apos;, function () &#123; return gulp.src(&apos;src/tpl/*.html&apos;) .pipe(gulp.dest(&apos;dist&apos;))&#125;)gulp.task(&apos;build&apos;, [&apos;css&apos;, &apos;js&apos;, &apos;html&apos;]) 命令行gulp build一下，回车！再看看dist文件夹，done！ 咋一看，好像没什么问题，但好像又有哪里不太对劲。不对啊，除了复制到dist文件夹，好像没啥功能啊，说好的压缩合并呢？说好的处理预编译呢？嗯，有了这个框架，这些功能我们想加多少加多少。 这样简单的项目，我们没法玩出花样，我们来点预编译语言，css用sass代替，html用swig代替： 12345678910- project |- src // 源文件夹 | |- tpl | | `- index.swig | |- sass | | `- index.scss | |- js | | `- index.js |- dist // 打包文件夹 `- package.json 编译sass需要安装gulp-sass模块，编译swig需要gulp-swig。注意到了吗？基本上gulp的模块都以gulp-*的形式出现，所以如果以后你使用gulp的时候想用什么模块，可以试试在npm搜gulp-模块名。 npm install gulp-sass gulp-swig --save-dev ————— 虚度光阴中 ————- 安装完后，我们再来修改一下配置文件gulpfile.js 1234567891011121314151617181920212223242526272829var gulp = require(&apos;gulp&apos;)var sass = require(&apos;gulp-sass&apos;)var swig = require(&apos;gulp-swig&apos;)gulp.task(&apos;sass&apos;, function () &#123; return gulp.src(&apos;src/sass/*.scss&apos;) .pipe(sass(&#123; outputStyle: &apos;compressed&apos; // 此配置使文件编译并输出压缩过的文件 &#125;)) .pipe(gulp.dest(&apos;dist/static&apos;))&#125;)gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(gulp.dest(&apos;dist/static&apos;))&#125;)gulp.task(&apos;tpl&apos;, function () &#123; return gulp.src(&apos;src/tpl/*.swig&apos;) .pipe(swig(&#123; defaults: &#123; cache: false // 此配置强制编译文件不缓存 &#125; &#125;)) .pipe(gulp.dest(&apos;dist&apos;))&#125;)gulp.task(&apos;build&apos;, [&apos;sass&apos;, &apos;js&apos;, &apos;tpl&apos;])再接着gulp build 再接着gulp build一下，编译结束，可以看看dist下是不是有index.html，dist/static下是不是有编译完成且压缩过的index.css，没有你找我！这里就不分别展示源文件和打包后文件的内容了，因为并不重要，想看演示项目内容的朋友，可以在文章结尾处找到本次演示项目的git仓库链接。各种预编语言和前端模板大家可以根据自己的喜好选择，笔者只是选择自己熟悉的几种来做演示。 到这里我们基本上已经完成打包的工作了，我们来试着搭建开发环境。 4. 搭建开发环境前文我们提到一个工具browser-sync，还记得吗？现在用得上了！我们先创建一个开发任务，像gulp build一样简单的任务，我们的目标是：没有蛀牙 一句话搞定。 123gulp.task(&apos;dev&apos;, [&apos;js:dev&apos;, &apos;sass:dev&apos;, &apos;tpl:dev&apos;], function () &#123; // do something here...&#125;) 看着好像稍有不同。这一次我们创建一个叫做dev的任务，这个任务先执行js:dev、sass:dev和tpl:dev三个任务，然后再执行回调里的内容，我们的本地服务器就是要在回调里去定义并且启动。 在这之前，我们先来了解一下browser-sync： Browsersync能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。 ——Browsersync中文网 事实上Browsersync可以理解为一个本地服务器，类似于Apache，不同的是，Browsersync只提供很简单的http功能，它的主要功能，是通过搭建一个本地服务器，并且监听文件的更改，自动刷新浏览器，实时地呈现最新内容。 browser-sync的用法： 1234567var browserSync = require(&apos;browser-sync&apos;).create()browserSync.init(&#123; server: &#123; baseDir: &quot;./&quot; // 设置服务器的根目录 &#125;&#125;) 其实也很简单，没有太多内容，现在我们要将它整合进我们的gulp任务里，捣鼓几下，我们得到： 1234567891011121314gulp.task(&apos;dev&apos;, [&apos;js:dev&apos;, &apos;sass:dev&apos;, &apos;tpl:dev&apos;], function () &#123; browserSync.init(&#123; server: &#123; baseDir: &quot;./dist&quot; // 设置服务器的根目录为dist目录 &#125;, notify: false // 开启静默模式 &#125;) // 我们使用gulp的文件监听功能，来实时编译修改过后的文件 gulp.watch(&apos;src/js/*.js&apos;, [&apos;js:dev&apos;]) gulp.watch(&apos;src/sass/*.scss&apos;, [&apos;sass:dev&apos;]) gulp.watch(&apos;src/tpl/*.swig&apos;, [&apos;tpl:dev&apos;])&#125;)这里的watch行为可以简单理解为：我（gulp）就这么盯着你（src/js/*.js文件），只要你 这里的watch行为可以简单理解为：我（gulp）就这么盯着你（src/js/*.js文件），只要你被改动了，我就马上执行js:dev任务来处理你，产生最新的文件。 那么，我们现在还需要补充一下js:dev、sass:dev和tpl:dev这三个任务，与原来的js、sass和tpl三个任务大同小异，这里笼统地过一遍就好，我们直接看代码： 1234567891011121314151617181920212223242526var browserSync = require(&apos;browser-sync&apos;).create()var reload = browserSync.reloadgulp.task(&apos;sass:dev&apos;, function () &#123; return gulp.src(&apos;src/sass/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/static&apos;)) .pipe(reload(&#123;stream: true&#125;))&#125;)gulp.task(&apos;js:dev&apos;, function () &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(gulp.dest(&apos;dist/static&apos;)) .pipe(reload(&#123;stream: true&#125;))&#125;)gulp.task(&apos;tpl:dev&apos;, function () &#123; return gulp.src(&apos;src/tpl/*.swig&apos;) .pipe(swig(&#123; defaults: &#123; cache: false // 此配置强制编译文件不缓存 &#125; &#125;)) .pipe(gulp.dest(&apos;dist&apos;)) .pipe(reload(&#123;stream: true&#125;))&#125;) 这里的reload方法，我们不需要过多了解，只要知道，通过执行它就可以刷新浏览器。这里的这里的reload方法，我们不需要过多了解，只要知道，通过执行它就可以刷新浏览器。这里的stream用法可以查阅官方文档，这里不重要所以不细讲。 值得留意的是：这里的sass:dev任务，我们并没有像sass任务一样配置编译模式为compressed，也就是不使用压缩功能，为什么呢？事实上，我们在开发的时候，并不需要压缩静态资源文件，可以说我们不在意它的体积是大一点还是小一点，我们在意的是样式是否写得符合期望，我们在乎的是功能是否实现，所以不需要启用压缩或者其他的什么优化功能，这样可以减轻编译的负担，加快编译速度。如果你对js或者图片也使用了压缩功能，建议在开发模式下去掉，只在打包模式下使用。最终我们整理得到一份gulpfile.js文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var gulp = require(&apos;gulp&apos;)var sass = require(&apos;gulp-sass&apos;)var swig = require(&apos;gulp-swig&apos;)var browserSync = require(&apos;browser-sync&apos;).create()var reload = browserSync.reloadgulp.task(&apos;sass&apos;, function () &#123; return gulp.src(&apos;src/sass/*.scss&apos;) .pipe(sass(&#123; outputStyle: &apos;compressed&apos; // 此配置使文件编译并输出压缩过的文件 &#125;)) .pipe(gulp.dest(&apos;dist/static&apos;))&#125;)gulp.task(&apos;js&apos;, function () &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(gulp.dest(&apos;dist/static&apos;))&#125;)gulp.task(&apos;tpl&apos;, function () &#123; return gulp.src(&apos;src/tpl/*.swig&apos;) .pipe(swig(&#123; defaults: &#123; cache: false // 此配置强制编译文件不缓存 &#125; &#125;)) .pipe(gulp.dest(&apos;dist&apos;))&#125;)gulp.task(&apos;sass:dev&apos;, function () &#123; return gulp.src(&apos;src/sass/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/static&apos;)) .pipe(reload(&#123;stream: true&#125;))&#125;)gulp.task(&apos;js:dev&apos;, function () &#123; return gulp.src(&apos;src/js/*.js&apos;) .pipe(gulp.dest(&apos;dist/static&apos;)) .pipe(reload(&#123;stream: true&#125;))&#125;)gulp.task(&apos;tpl:dev&apos;, function () &#123; return gulp.src(&apos;src/tpl/*.swig&apos;) .pipe(swig(&#123; defaults: &#123; cache: false // 此配置强制编译文件不缓存 &#125; &#125;)) .pipe(gulp.dest(&apos;dist&apos;)) .pipe(reload(&#123;stream: true&#125;))&#125;)gulp.task(&apos;dev&apos;, [&apos;js:dev&apos;, &apos;sass:dev&apos;, &apos;tpl:dev&apos;], function () &#123; browserSync.init(&#123; server: &#123; baseDir: &quot;./dist&quot; &#125;, notify: false &#125;) gulp.watch(&apos;src/js/*.js&apos;, [&apos;js:dev&apos;]) gulp.watch(&apos;src/sass/*.scss&apos;, [&apos;sass:dev&apos;]) gulp.watch(&apos;src/tpl/*.swig&apos;, [&apos;tpl:dev&apos;])&#125;) 嗯，完美，到这一步，我们这个自动化构建已经基本完成了，而且还算是完整。现在，我们开发的时候，就执行gulp dev，打包的时候就执行gulp build，是不是很方便？ 注意：gulp dev任务启动以后是一直保持工作状态的，也就是它不像gulp build一样一次性执行完，它是keep alive的，所以我们如果要停止这个任务，需要手动按ctrl+c组合键，结束这个任务。 5. 补充然而事情还没完，我们的目标是：装逼 尽善尽美！ 有三个地方其实我们还没做到位： 对命令进行包装，尽量简洁。gulp dev和gulp build其实已经很简洁了，但事实上这只是因为这个项目很简单，用到的命令很少，在开发复杂的项目时，我们通常要输入复杂的一长串的命令行。gulp dev其实也是gulp —gulpfile gulpfile.js dev的缺省写法而已，具体情况可以去gulp官网了解。所以我们需要有更简洁的方式去执行这些预先准备好的脚本，就好像windows系统下的快捷方式； 目前的情况是，我们每次执行，都会将文件拷贝到dist目录下，但是却没有删除的工作，也就是说文件数量只增不减，这样多次下来，随着文件的增删改动，必然会遗留很多没有用的文件。我们需要每次启动编译或者打包之前，先把整个dist文件夹删除，然后再重新生成dist； 上传的功能还没做呢？！ 二话不说就开工！ 第一点很好解决，我们可以把脚本作为一项配置存放在package.json文件中： 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a test project&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;gulp dev&quot;, // 开发脚本 &quot;build&quot;: &quot;gulp build&quot;, // 打包脚本 &quot;test&quot;: &quot;node ./build/test.js&quot; &#125;, &quot;author&quot;: &quot;jack lo&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.13.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot;, &quot;gulp-swig&quot;: &quot;^0.8.0&quot; &#125;&#125;注意到了吗？scripts项就是用来预定义脚本的地方，我们可以很方便地把脚本按照上面 注意到了吗？scripts项就是用来预定义脚本的地方，我们可以很方便地把脚本按照上面的形式封装好，然后执行的方式就变成了： npm run dev // 执行开发 npm run build // 执行打包 搞定！ 我们接着看第二点，删除dist文件夹，多简单的事啊！鼠标右键，删除，搞定！ …… 哪有这么low的事，我们的目标是：懒癌晚期 能不自己做的事情，绝不自己动手。 有一个叫做rimraf的包，可以帮我们做这事，我们需要用到它的cli，所以跟gulp一样，我们全局安装它： npm install rimraf -g 安装完后，我们再重新修改一下package.json文件中的scripts内容： 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;a test project&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;gulp dev&quot;, // 开发脚本 &quot;build&quot;: &quot;rimraf dist &amp;&amp; gulp build&quot;, // 打包脚本 &quot;test&quot;: &quot;node ./build/test.js&quot; &#125;, &quot;author&quot;: &quot;jack lo&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;browser-sync&quot;: &quot;^2.13.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot;, &quot;gulp-swig&quot;: &quot;^0.8.0&quot; &#125;&#125;ok，现在试试执行npm run build，dist文件夹是不是先被删除，然后再重新生成了？ ok，现在试试执行npm run build，dist文件夹是不是先被删除，然后再重新生成了？ 完美。 第三点放到最后才补充，主要是考虑到它并不是必要的，因为有些项目并不需要ftp上传，一般是提交svn，然后再由后端或者运维去部署，笔者是需要将静态资源上传到cdn服务器进行加速的，所以需要这样一个任务，在此我们简单介绍一下。 举一反三一下，我们再创建一个upload任务： 1234567891011121314var ftp = require(&apos;gulp-ftp&apos;)var gutil = require(&apos;gulp-util&apos;)gulp.task(&apos;upload&apos;, function () &#123; return gulp.src(&apos;dist/**&apos;) .pipe(ftp(&#123; host: &apos;8.8.8.8&apos;, // 远程主机ip port: 22, // 端口 user: &apos;username&apos;, // 帐号 pass: &apos;password&apos;, // 密码 remotePath: &apos;/project&apos; // 上传路径，不存在则新建 &#125;)) .pipe(gutil.noop())&#125;) 自行安装一下gulp-ftp和gulp-util两个包，然后在package.json文件中的scripts补充一个脚本npm run upload来执行gulp upload。 笔者通常都是打包之后顺便上传，命令行直接输入npm run build &amp;&amp; npm run upload，回车，然后就可以愉快地去跟旁边的妹纸聊天了。 6. 总结到这里，我们已经完整搭完了这一套简易自动化工具，好像讲了很多东西，其实总结起来内容非常少：我们只不过分别用三个小任务（sass、js、tpl），组成了build和dev这两个大任务，仅此而已。熟练的情况下操作起来，整个过程也不过十分钟！ ps:网络太差怪我咯？呵呵。 由于时间和篇幅关系，我们只简单处理了css、js和html，事实上，你还可以在这个基础上继续完善下去，js可以由coffeejs编译得到，而且还可以继续压缩，甚至可以把全部js文件合并成一个！html也一样可以继续压缩。而且，你完全可以自己创建一个任务去处理其他诸如图片、字体等等。 好啦，简易版就讲到这里了。","tags":[]}]